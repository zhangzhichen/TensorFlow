1.服务
2.队列
3.发布订阅的方式。

1.解耦
2.流量削峰
3.异步通信

rabbitMQ特性:
1.高可靠
2.灵活的路由
3.支持多客户端（多语言）
4.集群和扩展性
5.高可用队列
6.权限管理
7.插件系统
8.可靠性
9.与spring集成


需要安装一个客户端才能使用rabbitMQ，服务叫broker（中介）

channel减少对服务器的消耗

binding key 绑定键
# 0个或多个单词
* 不多不少1个单词

死信交换机（dead letter exchange）
死信队列(dead letter queue)

死信条件:
1.消费者拒绝
2.消息过期
3.队列达到最大长度

延迟队列:
1.利用超时时间将消息进入死信队列，再进行发送。
2.delayed-message-exchange 延迟队列  

延迟队列比死信队列的好处：
1.死信队列的延迟队列数量需要有很多（比如5分钟，10分钟）
2.死信队列会占用比较多的内存开销。

rabbitMQ消息可靠性投递
1.生产者放消息给broker，
1）transaction模式。channel.txSelect();提交事务:channel.txCommit();说明成功 channel.txRollBack()。但是会大量占用资源，通信浪费。
2）confirm模式。 channel.confirmSelect()   channel.waitForConfirmOrDie() 可以批量确认。
3）addConfirmListener 异步确认模式。
2.交换机路由给队列，是否正确。
3.队列没有人消费，
4.队列投递给消费者，什么时候才能删除队列顶部的数据


Step1：Producer所发送的数据是我们的业务数据，比如订单信息。Producer在发送消息之前给我们的订单信息写入我们的本地数据库（BIZ DB)中，BIZ DB是我们的业务数据库，接着将要发送到消息存储到消息记录数据库中(MSG DB)，这个MSG DB就是存储所有发送给Rabbitmq的消息记录用的，写入消息记录表中该记录字段status(状态)会有几个值，比如0表示消息发送中，1表示发送成功，2表示消息发送失败，。
　　Step2：应用程序要消息发送给Rabbitmq的Broker，这个发送的消息属于confirm模式，发送后需要Rabbitmq确认。
　　Step3：Rabbitmq Broker收到消息后会给Producer一个应答来确认信息，说我已经收到消息了。
　　Step4：紧跟上一步，Producer一直在监听（Listener）Broker所确认的信息，在收到消息之后，根据收到消息的结果再去更新MSG DB中的消息发送状态，将记录status字段更新为1。
　　Step 5：但是在消息确认这个过程中可能由于网络闪断、MQ Broker端异常等原因导致 回送消息失败或者异常。这个时候就需要发送方（生产者）对消息进行可靠性投递了，保障消息不丢失，100%的投递成功！（有一种极限情况是闪断，Broker返回的成功确认消息，但是生产端由于网络闪断没收到，这个时候重新投递可能会造成消息重复，需要消费端去做幂等处理）所以我们需要有一个定时任务，（比如每5分钟拉取一下处于中间状态的消息，当然这个消息可以设置一个超时时间，比如超过1分钟 Status = 0 ，也就说明了1分钟这个时间窗口内，我们的消息没有被确认，那么会被定时任务拉取出来）。
Step 5：但是在消息确认这个过程中可能由于网络闪断、MQ Broker端异常等原因导致 回送消息失败或者异常。这个时候就需要发送方（生产者）对消息进行可靠性投递了，保障消息不丢失，100%的投递成功！（有一种极限情况是闪断，Broker返回的成功确认消息，但是生产端由于网络闪断没收到，这个时候重新投递可能会造成消息重复，需要消费端去做幂等处理）所以我们需要有一个定时任务，（比如每5分钟拉取一下处于中间状态的消息，当然这个消息可以设置一个超时时间，比如超过1分钟 Status = 0 ，也就说明了1分钟这个时间窗口内，我们的消息没有被确认，那么会被定时任务拉取出来）
Step 6：接下来我们把中间状态的消息进行重新投递 retry send，继续发送消息到MQ ，当然也可能有多种原因导致发送失败
Step 7：我们可以采用设置最大努力尝试次数，比如投递了3次，还是失败，那么我们可以将最终状态设置为Status = 2 ，最后 交由人工解决处理此类问题（或者把消息转储到失败表中）。



自动的ack:
消费者接收到消息就立即返回ack

交换机与队列，队列与消费者的绑定关系是什么样的：
1.多对多
2.1对多，采用轮询策略（具体一次取出几条，prefetch count决定）

无法被路由的消息，去了哪里：
1.回发，备份的交换机。
2.丢弃

一个项目要从多个服务器接受消息，怎么做？
一个项目要发送消息到多个服务器，怎么做？
ConnectionFactory Template ListenerContainer

一个消息队列最多可以存放多少条消息。
取决于硬件，可以是存放磁盘，可以是内存。如果没有配置最大队列长度，就取决于硬件的大小。

